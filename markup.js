module.exports = (function(){
  /* Generated by PEG.js-fn 0.7.0, Functional modification by shaman.sir@gmail.com (http://shamansir.github.io/pegjs-fn/). */
  /* Original version developed by David Majda (http://pegjs.majda.cz/) */
/*
*
* The user-created (parser rules) part of this code is owned by W.Hodges under the 
* Creative Commons License CC BY-NC-ND
* (Attribution-NonCommercial-NoDerivs)
* This means that you can use and share this code, 
* but are not allowed to edit, change, or sell this code.
* https://creativecommons.org/licenses/by-nc-nd/4.0/
*
*/
  
  /* ########### ENVIRONMENT ########### */
  
  var input,
      options;
  
  var pos, // 0, parser position
      p_pos; // 0, previous parser position
  
  
  // This code encloses all of the user blocks (initializer and/or actions)
  // in their own sandbox, so if there is an initializer, its inner variables
  // will [only] be accessible to actions; this, however, requires an initializer
  // not to have any first-level return statements. Also, this approach keeps parser
  // inner variables safe from user access, except the ones defined above.
  var __p_blocks = (function() { return function() {
    
    // backwards compatibility with original peg-js
    function offset() { return p_pos; }
    function text() { return input.substring(p_pos, pos); }
    
    /* ########### USER CODE ########### */
    
    
    /* ----------- BLOCKS ----------- */
    
    // Blocks are grouped by rule name and id; they all get access to current context
    // through $ctx variable which they expand into their arguments. Arguments
    // names are precalculated during parser generation process.
    
    // $f and $ctx variables are named so creepy just to ensure that parser writer will not use them
    // for naming variables in his code (only $ctx may clash in this architecture, in fact),
    // we hope any modern environment supports Unicode now
    
    return {
      "tag": [
        function($ctx) {
          // tag[0]
          return (function(next,val,first,inside,whitespace,second) {
             return "<"+first +" "+ next + "='"+val+"'>"+inside+second.join(" ") +"</"+first+">"
          })($ctx.next,$ctx.val,$ctx.first,$ctx.inside,$ctx.whitespace,$ctx.second);
        }
      ],
      "string": [
        function($ctx) {
          // string[0]
          return (function(first) {
            return first.join("")
          })($ctx.first);
        }
      ],
      "insideString": [
        function($ctx) {
          // insideString[0]
          return (function(first) {
            return first.join("")
          })($ctx.first);
        }
      ],
      "insideContent": [
        function($ctx) {
          // insideContent[0]
          return (function(first) {
             return first.join("")
          })($ctx.first);
        }
      ],
      "insideValue": [
        function($ctx) {
          // insideValue[0]
          return (function(first) {
             return first.join("")
          })($ctx.first);
        }
      ]
    };
    
  }; })();
  
  // $f and $ctx variables are named so creepy just to ensure that parser writer will not use them
  // for naming variables in his code (only $ctx may clash in this architecture, in fact),
  // we hope any modern environment supports Unicode now
  var $f = null; // holds a pointer to current rule blocks, will be initialized in parse() function
  
  /* ########### PARSER ########### */
  
  var __parser = function() {
    
  /* =========== PARSER-DEPENDENT CODE =========== */
    
    /* ----------- RULES DEFINITIONS ----------- */
    
    var rules = {}; (function() {
    
    rules.start = function() {
      return (
        ref(rules.tag)
      ());
    };
    
    rules.tag = function() {
      var _code = $f.tag;
      return (
        action(
          seqnc(
            match("{"),
            label("next",
              maybe(
                ref(rules.insideContent)
              )
            ),
            label("val",
              maybe(
                ref(rules.insideValue)
              )
            ),
            label("first",
              ref(rules.string)
            ),
            label("inside",
              maybe(
                ref(rules.insideString)
              )
            ),
            label("whitespace",
              maybe(
                ref(rules.whitespace)
              )
            ),
            label("second",
              any(
                ref(rules.tag)
              )
            ),
            match("}")
          ),
          /*{ return "<"+first +" "+ next + "='"+val+"'>"+inside+second.join(" ") +"</"+first+">"}*/
          _code[0])
      ());
    };
    
    rules.string = function() {
      var _code = $f.string;
      return (
        action(
          label("first",
            any(
              ref(rules.char)
            )
          ),
          /*{return first.join("")}*/
          _code[0])
      ());
    };
    
    rules.char = function() {
      return (
        re(/^[a-zA-z0-9" "]/, "[a-zA-z0-9\" \"]")
      ());
    };
    
    rules.whitespace = function() {
      return (
        seqnc(
          maybe(
            match("\n")
          ),
          maybe(
            match(" ")
          ),
          maybe(
            match("\t")
          )
        )
      ());
    };
    
    rules.insideString = function() {
      var _code = $f.insideString;
      return (
        action(
          seqnc(
            match(":"),
            label("first",
              any(
                ref(rules.char)
              )
            ),
            match(":")
          ),
          /*{return first.join("")}*/
          _code[0])
      ());
    };
    
    rules.contentString = function() {
      return (
        re(/^[a-zA-Z0-9"="]/, "[a-zA-Z0-9\"=\"]")
      ());
    };
    
    rules.insideContent = function() {
      var _code = $f.insideContent;
      return (
        action(
          seqnc(
            match("*"),
            label("first",
              any(
                ref(rules.char)
              )
            ),
            match("*")
          ),
          /*{ return first.join("")}*/
          _code[0])
      ());
    };
    
    rules.insideValue = function() {
      var _code = $f.insideValue;
      return (
        action(
          seqnc(
            match("&"),
            label("first",
              any(
                ref(rules.char)
              )
            ),
            match("&")
          ),
          /*{ return first.join("")}*/
          _code[0])
      ());
    };
    
    })();
    
    /* ----------- OPERATORS ----------- */
    
    // get current char
    function cc() { return (pos < ilen) ? input.charAt(pos) : EOI; }
    
    var ref = def(inctx); // will call rule inside context
    
    function action(f, code) {
      return inctx(function() {
        p_pos = pos; var res; // save previous position
        f(); res = code(cctx);
        if (res === null) { pos = p_pos;
           failed(SOMETHING, NOTHING); }
        return res;
      });
    }
    action = def(action);
    
    function seqnc(/*f...*/) {
      var p_pos = pos; // save previous position locally
      var fs = arguments,
          s = [],
          on_miss = function(e) {
                        pos = p_pos; throw e; };
      for (var fi = 0, fl = fs.length;
           fi < fl; fi++) {
        s.push(safe(fs[fi], on_miss));
      }
      return s;
    }
    seqnc = def(seqnc);
    
    function match(str) {
      var slen = str.length;
      if ((pos + slen) > ilen) {
        failed(quote(str), EOI); // exits
      }
      if (input.substr(pos, slen) === str) {
        pos += slen;
        return str;
      }
      failed(quote(str), cc());
    }
    match = def(match);
    
    function label(lbl, f) {
      return cctx[lbl] = f();
    }
    label = def(label);
    
    function any(f) {
      var s = [],
          missed = 0,
          on_miss = function() { missed = 1; };
      while (!missed) {
        s.push(safe(f, on_miss));
      }
      if (missed) s.splice(-1);
      return s;
    }
    any = def(any);
    
    function maybe(f) {
      var missed = 0,
          res = safe(f, function() {
        missed = 1;
      });
      if (missed) return '';
      return res;
    }
    maybe = def(maybe);
    
    function re(rx, desc) {
      var res, desc = desc || rx.source;
      if (res = rx.exec(input.substr(pos))) {
         if (res.index !== 0) failed(desc, cc());
         pos += res[0].length;
         return res[0];
      } else failed(desc, cc());
    }
    re = def(re);
    
  /* =========== PARSER-INDEPENDENT CODE =========== */
    
    /* ----------- VARIABLES ----------- */
    
    var ctx, // { ... }, root of the context
        cctx; // { ... }, current context pointer
    
    var current, // '-', current rule name
        alias; // '', current rule alias, if defined
    
    var failures, // {}, failures data
        rmfpos, // 0, rightmost failure position
        nr; // 0, no-report, fire errors w/o reporting
    
    var /*input, */ilen; // input, input length
    
    /* ----------- CONTEXT ----------- */
    
    function prepare_ctx() { return ctx_lvl(); }
    function ctx_lvl(parent) {
      function CtxLevel() {
          this.__p = parent;
          this.__c = null;
      }
      CtxLevel.prototype = parent;
      return new CtxLevel();
    }
    function din() {  // dive in
      if (!cctx.__c) cctx.__c = ctx_lvl(cctx);
      cctx = cctx.__c;
    }
    function dout() { // dive out
      if (!cctx.__p) throw new Error('reached top context level');
      cctx = cctx.__p;
    }
    function inctx(f) { // execute in own context and return
      var r, e;
      din(); r = safe(f, function(err) { e = err; });
      dout(); if (e) throw e;
      return r;
    }
    
    /* ----------- DEFERRED ----------- */
    // Makes passed function to save its argument values,
    // but not execute until specially requested
    
    function def(f) {
      return function() {
        return (function(f, args) {
          return function() { return f.apply(null, args); };
        })(f, arguments);
      };
    }
    
    /* ----------- RULES WRAPPER ----------- */
    
    function wrap(name, rule) {
      return function() { current = name; return rule(); };
    }
    for (var rule in rules) {
      rules[rule] = wrap(rule, rules[rule]);
    }
    
    /* ----------- RESULT OBJECT + PARSE FUNCTION ----------- */
    
    var result = {
      /*
       * Parses the input with a generated parser. If the parsing is successfull,
       * returns a value explicitly or implicitly specified by the grammar from
       * which the parser was generated (see |PEG.buildParser|). If the parsing is
       * unsuccessful, throws |PEG.parser.MatchFailed| describing the error.
       */
      parse: function(_input, _opts) {
        
        // initialize variables
        pos = 0, p_pos = 0, input = _input, options = _opts || {};
        
        ilen = input.length, failures = {}, rmfpos = 0, nr = 0;
        
        ctx = prepare_ctx(), cctx = ctx;
        
        current = '-';
        
        var startRule = options.startRule || "start";
        if (["start"].indexOf(startRule) < 0) {
          throw new Error("Can't start parsing from rule " + quote(startRule) + ".");
        }
        
        // call user initializer and also
        // get blocks lying in the same context
        $f = __p_blocks();
        
        // find start rule
        if (startRule) {
          if (rules[startRule] === undefined) {
            throw new SyntaxError("Rule not found: " + quote(startRule) + ".");
          }
        } else {
          throw new Error("Start rule is not defined in options, no 'start' rule found and first rule in grammar was empty");
        }
        
        // and execute it
        var res;
        try {
          res = rules[startRule]();
          if ((pos < ilen) || 
              (res === null)) failed(EOI, cc());
        } catch(e) {
          if (e instanceof _MatchFailed) {
            // throw rightmost error instead
            throw adapt(failures[rmfpos]);
          }
          throw e;
        }
        
        return res;
      },
      
      
      /* makes error type accessible outside */
      MatchFailed: _MatchFailed,
      SyntaxError: _SyntaxError
    };
    
    /* ----------- UTILS ----------- */
    
    function Marker(human_str) { this.str=human_str; }
    Marker.prototype.toString = function() { return this.str; };
    var EOI = new Marker('end of input'),
        ANY = new Marker('any character'),
        SOMETHING = new Marker('progress'),
        NOTHING = new Marker('nothing');
    
    function hexOf(ch) {
      var x = ch.charCodeAt(0),
          v = x.toString(16).toUpperCase(),
          h = (x > 0xFF),
          i = (h ? 4 : 2) - v.length;
      while (i--) v = v + '0';
      return '\\' + (h ? 'u' : 'x') + v;
    }
    
    function quote(s) {
      /*
       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
       * string literal except for the closing quote character, backslash,
       * carriage return, line separator, paragraph separator, and line feed.
       * Any character may appear in the form of an escape sequence.
       *
       * For portability, we also escape escape all control and non-ASCII
       * characters. Note that "\0" and "\v" escape sequences are not used
       * because JSHint does not like the first and IE the second.
       */
      return '"' + s
        .replace(/\\/g, '\\\\')  // backslash
        .replace(/"/g, '\\"')    // closing quote character
        .replace(/\x08/g, '\\b') // backspace
        .replace(/\t/g, '\\t')   // horizontal tab
        .replace(/\n/g, '\\n')   // line feed
        .replace(/\f/g, '\\f')   // form feed
        .replace(/\r/g, '\\r')   // carriage return
        .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, hexOf)
        + '"';
    }
    
    /* ----------- FAILURES ----------- */
    
    function _MatchFailed(what, found, expected) {
      this.what = what;
      this.expected = expected || [];
      this.found = found;
      this.offset = pos;
      this.xpos = [-1, -1];
      this.line = -1;
      this.column = -1;
    }
    _MatchFailed.prototype = new Error();
    _MatchFailed.prototype.toString = 
       function() { return 'MatchFailed: '+emsg(this); };
    var merr = function(fnd, exp) {
      return new _MatchFailed(alias || current, fnd, exp);
    };
    
    function failed(expected, found) {
      var expected = alias || expected;
      // if no report required, just throw
      if (nr) throw merr(found, [expected]);
      if (pos > rmfpos) rmfpos = pos;
      var e = failures[pos] ||
             (failures[pos] = merr(found));
      /*if (e.found !== found)*/ e.found = found;
      var prev = e.expected;
      var f; for (var i = prev.length; i--;) {
        if (prev[i] === expected) {
          f = 1; break;
        }
      }; if (!f) prev.push(expected);
      throw e;
    }
    
    function safe(f, callback) {
      try { return f();
      } catch(e) {
        if (e instanceof _MatchFailed) {
          if (callback) callback(e);
        } else { throw e; }
      }
    }
    
    function emsg(e) {
      var found_str, exp_str;
      if (e.found instanceof Marker) {
        found_str = e.found.str;
      } else {
        found_str = quote(e.found);
      }
      if (e.expected instanceof Marker) {
        exp_str = e.expected.str;
      } else if ((e.expected.length === 1) &&
          (e.expected[0] instanceof Marker)) {
        exp_str = e.expected[0].str;
      } else {
        var xs = e.expected;
        exp_str = ((xs.length > 1)
                  ? (xs.slice(0,-1).join(', ')+' '+
                    'or '+xs.slice(-1))
                  : xs[0]);
      }
      return /*'Stopped at '+quote(e.what)+': */'Expected '+exp_str+
             ' but '+found_str+' found.';
    }
    function adapt(e) {
      e.message = emsg(e);
      if ((e.found instanceof Marker) && (e.found === EOI)) e.found = null;
      var xs = e.expected.sort();
      if ((xs.length === 1) &&
          (xs[0] === EOI)) {
        e.expected = [];
      }
      for (var i = xs.length; i--;)
        { if (xs[i] instanceof Marker) xs[i] = xs[i].str; }
      return e;
    }
    
    function _SyntaxError(msg) { // may be thrown from parser
      this.message = msg;
    }
    _SyntaxError.prototype = new Error();
    _SyntaxError.prototype.toString = 
       function() { return 'SyntaxError: '+this.message; };
    
    /* ---------- RETURN RESULT OBJECT ----------- */
    
    return result;
    
  };
  
  
  /* ----------- RETURN PARSER ----------- */
  return __parser();
  
})();
